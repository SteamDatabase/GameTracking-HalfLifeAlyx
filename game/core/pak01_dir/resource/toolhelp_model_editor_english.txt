"lang"
{
	"Tokens"
	{
		"Element.CVpropDataList:help"		"Edit the data added to the model\'s prop data here. These are the same fields that existed in Source1\'s keyvalues block. "
		"Attribute.CVpropDataList.m_nBreakableType:help"		"The type of pieces the model will shatter into. "
		"Attribute.CVpropDataList.m_nBreakableCount:help"		"How many pieces the model shatters into."
		"Attribute.CVpropDataList.m_nBreakableSkin:help"		"Which skin the break piece uses"
		"Attribute.CVpropDataList.m_additional:help"		"Add additional keyvalues here"
		"Attribute.CVpropDataList.m_base:shorthelp"		"Specify a base propdata class to derive from"
		"Attribute.CVpropDataList.m_base:help"		"Specify a base propdata class to derive from (base types can be found in propdata.txt)\n\n<a href=\'https://intranet.valvesoftware.com/index.php/Prop_Data_(Left_4_Dead)\'>Left4 Dead Prop Data</a>"
		"Attribute.CVpropDataList.m_bBlockLOS"		"Block LOS"
		"Attribute.CVpropDataList.m_bBlockLOS:help"		"Override whether this prop should block NPC\'s Line-Of-Sight."
		"Attribute.CVpropDataList.m_bAIwalkable:help"		"Override whether AI should consider this prop as walkable on."
		"Attribute.CVpropDataList.m_bAllowStatic:help"		" Allow this prop to be static as well as physically simulated."
		"Attribute.CVpropDataList.m_flDmgBullets:shorthelp"		"Mod damage done by bullets to this prop."
		"Attribute.CVpropDataList.m_flDmgBullets:help"		"Mod damage done by bullets to this prop.\n\nNOTE: Use damage modifiers to reflect differences between the amount of\ndamage that an object takes from different damage types. Don\'t\nuse them to reflect overall damage strength. i.e. Stone is resilient\nto everything. To reflect this, increase the health of all stone\nobjects, don\'t set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgClub:shorthelp"		"Mod damage done by clubs to this prop."
		"Attribute.CVpropDataList.m_flDmgClub:help"		"Mod damage done by clubs to this prop.\n\nNOTE: Use damage modifiers to reflect differences between the amount ofdamage that use them to reflect overall damage strength. i.e. Stone is resilient\nto everything. To reflect this, increase the health of all stone\nobjects, don\'t set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgExplosive"		"Mod damage done by explosives to this prop."
		"Attribute.CVpropDataList.m_flDmgExplosive:help"		"Mod damage done by explosives to this prop.\n\nNOTE: Use damage modifiers to reflect differences between the amount ofdamage that use them to reflect overall damage strength. i.e. Stone is resilient\nto everything. To reflect this, increase the health of all stone\nobjects, don\'t set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgFire:shorthelp"		"Mod damage done by fire to this prop."
		"Attribute.CVpropDataList.m_flDmgFire:help"		"Mod damage done by fire to this prop.\n\nNOTE: Use damage modifiers to reflect differences between the amount of\ndamage that an object takes from different damage types. Don\'t\nuse them to reflect overall damage strength. i.e. Stone is resilient\nto everything. To reflect this, increase the health of all stone\nobjects, don\'t set the damage modifiers lower."
		"Attribute.CVpropDataList.m_damageTable:help"		"Specify a custom physics impact damage table for this prop."
		"Attribute.CVpropDataList.m_nExplosionType:shorthelp"		"(molotov/grenade/fireworks/default)"
		"Attribute.CVpropDataList.m_nExplosionType:help"		"If default, explosive_damage/explosive_radius are used as usual"
		"Attribute.CVpropDataList.m_flExplosiveDamage:shorthelp"		"Explosive damage done by this prop."
		"Attribute.CVpropDataList.m_flExplosiveDamage:help"		"Explosive damage done by this prop.\n\nRadius of the explosion caused by this prop when it breaks.//\t\tNOTE: If radius and damage are specified for a prop, then the prop will automatically create an explosion with the specified values when the prop is broken."
		"Attribute.CVpropDataList.m_flExplosiveRadius:shorthelp"		"Radius of the explosion caused by this prop when it breaks."
		"Attribute.CVpropDataList.m_flExplosiveRadius:help"		"Radius of the explosion caused by this prop when it breaks.//\t\tNOTE: If radius and damage are specified for a prop, then the prop will automatically create an explosion with the specified values when the prop is broken."
		"Attribute.CVpropDataList.m_nMultiplayerBreak:shorthelp"		"Set multiplayer breakable spawn behavior (default/server/client/both)"
		"Attribute.CVpropDataList.m_nMultiplayerBreak:help"		"Set multiplayer breakable spawn behavior (default/server/client/both)<br>\n\nNOTE: if multiplayer_break is \"both\", each piece is spawned by the default dll unless its \"break\" section has a \"multiplayer_break\" key with a value of \"client\" or \"server\".<br>\n\nNOTE: if specifying non-default behavior, the top-level breakable and the breakable pieces need to \"agree\".<br>"
		"Attribute.CVpropDataList.m_nHealth:help"		" Amount of damage this prop should take before breaking."
		"Attribute.CVpropDataList.m_flExplosiveDelay:shorthelp"		"Time before explosion occurs"
		"Attribute.CVpropDataList.m_bGlow:shorthelp"		"Does the prop get a l4d style glow"
		"Attribute.CVpropDataList.m_nPhysicsMode:help"		"Set multiplayer physics behaviour (1=full, 2=non-solid,3=clientside)"
		"Attribute.CVpropDataList.m_physgunInteractions:help"		"Set the physgun_interaction keyvalues here"
		"Element.CVhitBoxSetList:shorthelp"		"HitboxSetList"
		"Element.CVhitBoxSetList:help"		"Hitboxsetlists contain a list of hitbox sets.<br>\nTo add a new set, right click in the item and select <b>\"Add Hitbox Set\"</b>"
		"Element.CVhitBoxSet:shorthelp"		"Hitbox set"
		"Element.CVhitBoxSet:help"		"Hitbox sets contain a list of hitboxes.<br>\nRight click the item to get these menu options:<br>\n<b>Auto Populate Set</b>: brings up a menu that allows you to select what joints get a hitbox<br>\nHitboxes are automatically sized based on the skinned vertices.<br>\n"
		"Attribute.CAuthPhysBody.m_pBreakablePartData"		"Breakable Part Override"
		"Attribute.CAuthPhysBody.m_pBreakablePartData:shorthelp"		"Per-part breakable attributes override"
		"Attribute.CAuthPhysBody.m_pBreakablePartData:help"		"Provides per-body part breakable attributes, e.g. fadeout time can be set to be shorter for smaller insignificant parts of a breakable than for bigger parts."
		"Element.CVModel"		"VMDL"
		"Element.CVModel:help"		"This is the high level content side file that is compliled to generate a game side model ( .vmdl_c ). All data needed for a model is either directly part of or referenced by the vmdl."
		"Element.CVmeshList"		"Mesh List"
		"Element.CVmeshList:help"		"This is a list of meshes that the model contains. Meshes in this list can be referenced by mesh groups, and LOD ( level of detail ) groups."
		"Element.CVmesh"		"VMesh"
		"Element.CVmesh:help"		"This is the data that describes a mesh file. Valid input files are .dmx, .fbx, .obj, and .smd."
		"Attribute.CVmesh.m_meshName"		"Mesh Name"
		"Attribute.CVmesh.m_meshName:help"		"The name of the mesh. "
		"Attribute.CVmesh.m_meshFile"		"Mesh File"
		"Attribute.CVmesh.m_meshFile:help"		"The content side file that is compiled. Valid file types are .dmx, .fbx, .smd, and .obj"
		"Attribute.CVmesh.m_materialSearchPath"		"Material Search Path"
		"Attribute.CVmesh.m_materialSearchPath:help"		"Optional mod relative path that adds an additional search path where the compiler looks for materials. For example entering \"materials/environments/rocks/\" will add that as a possible location for materials, in addition to looking in the location  contained in the input mesh file."
		"Attribute.CVmesh.m_bSkinParentedObjects"		"Skin Parented Objects"
		"Attribute.CVmesh.m_bSkinParentedObjects:help"		"Enabling this will force a hierarchy of objects to be treated as a joint based skeleton. For example a chain of parented cubes will show up as a series of joints with the cubes skinned to each joint. This is on by default."
		"Attribute.CVmesh.m_bExpensiveTangents"		"Use Expensive Tangents"
		"Attribute.CVmesh.m_bExpensiveTangents:help"		"Enabling this will use uncompressed tangents. This will result in better looking results in some cases, but will also increase the size of the compiled model."
		"Attribute.CVmesh.m_bIgnoreCloth"		"Ignore Cloth Attributes"
		"Attribute.CVmesh.m_bIgnoreCloth:shorthelp"		"Act as if there are no cloth_enable and other cloth_* maps painted on the mesh. When checked, no cloth will be created from this mesh. "
		"Attribute.CVmesh.m_bIgnoreCloth:help"		"<p>Act as if there are no cloth_enable and other cloth_* maps painted on the mesh. When checked, no cloth will be created from this mesh. </p>\n<p>Useful for temporarily turning off cloth, or, when using joint-backsolved proxies, switching between using the joints authored with the mesh, and using joints generated from the cloth proxy.</p>\n<p>When you use a cloth proxy, it normally generates a joint per proxy vertex, resulting in a lot of joints. Sometimes you want to control how the cloth mesh bends (for visual performance) and how many joints you have in the mesh (for animation/CPU performance). In those cases, you can check \"Back-solve joints\" in the proxy, which will not stop proxy from generating per-vertex joints, but will ensure that the joints that are already in the mesh are back-solved and move with the cloth. If you don\'t have any cloth_enable painted on the render mesh (or if you check Ignore Cloth Attributes), the render mesh will only be bound to the authored joints, and the generated proxy joints will not be used, and thus will be omitted from the model skeleton, potentially saving some perf.</p>\n\n<p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' /></p>\n"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs"		"Map Using UVs"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs:shorthelp"		"Use UV coordinates to match cloth proxy mesh to the render mesh"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs:help"		"Use UV coordinates to match cloth proxy mesh to the render mesh. \nBy default, cloth proxy doesn\'t have to have UVs, and render mesh is projected onto cloth proxy mesh directly using the authored (undeformed) relaxed mesh positions.\nNot implemented as of Dec 2014"
		"Attribute.CVClothProxyMesh.m_flEnvelope"		"Envelope"
		"Attribute.CVClothProxyMesh.m_flEnvelope:shorthelp"		"The max distance to project render mesh onto cloth proxy mesh. Range: 0 - infinity (inches)"
		"Attribute.CVClothProxyMesh.m_flEnvelope:help"		"The max distance to project render mesh onto cloth proxy mesh. Range: 0 - infinity (inches)\nWhen trying to map cloth proxy mesh onto render mesh (which may have totally different topology and strucutre), the render mesh vertices are projected onto polygons of cloth proxy mesh. This is the maximum projection distance between the render mesh vertices and corresponding points on the cloth proxy mesh polygons they are projected onto. \nBy default , this is set to a large value to make it possible to project anything onto anything to always get some result, but sometimes it may not be desirable.\n"
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges"		"Collapse Tiny Edges"
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges:shorthelp"		"Collapse edges below threshold. May be used to create ropes out of polygons."
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges:help"		"Collapse edges below threshold. May be used to create ropes out of polygons.\nAny edge shorter than the specified length will be collapsed. As a result, sliver quads or tris may be converted to rods (elements of ropes). Not implemented as of Dec 2014"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold"		"Back-solve min weight"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold:shorthelp"		"Range: 0-1. Minimal joint blend weight for that joint to be affected by back-solving"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold:help"		"<p>Range: 0-1. Minimal joint blend weight for that joint to be affected by back-solving.</p><p>\nBack-solving a joint involves taking the vertices that are bound to it, and computing where the joint should be to match those vertices as close as possible. When a vertex-joint blend weight is below this threshold, this vertex will not be used for that computation.</p><p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' /></p>"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints"		"Back-solve joints"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints:shorthelp"		"Back-solve joints from deformed vertices"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints:help"		"<p><b>Back-solve joints from deformed vertices.</b></p>\n<p>\nSometimes it\'s useful for the authored joints to be moved by cloth. It\'s not useful when you want to animate them, when you want the animation to affect the cloth. But when you want un-animated joints to be moved by cloth, this is your checkbox.\nCloth proxy vertices may be bound to some joints. Those joints may directly move those vertices if they are static (when cloth_enable attribute is black). But when those vertices are dynamic (cloth_enable attribute is white), they can affect (rotate and move) the joints. The joints are solved to try to match the simulated vertex positions as close as possible (without scale or skew). This flag may be used in conjunction with render mesh without cloth attributes or with cloth attributes ignored (see Ignore Cloth Attributes option on render mesh). If the render mesh doesn\'t follow cloth, it still follows the originally authored (and maybe animated) joints. With this checkbox, cloth will move and rotate those joints.\n</p><p>\nWhen you use a cloth proxy, it normally generates a joint per proxy vertex, resulting in a lot of joints. Sometimes you want to control how the cloth mesh bends (for visual performance) and how many joints you have in the mesh (for animation/CPU performance). In those cases, you can check \"Back-solve joints\" in the proxy, which will not stop proxy from generating per-vertex joints, but will ensure that the joints that are already in the mesh are back-solved and move with the cloth. If you don\'t have any cloth_enable painted on the render mesh (or if you check Ignore Cloth Attributes), the render mesh will only be bound to the authored joints, and the generated proxy joints will not be used, and thus will be omitted from the model skeleton, potentially saving some perf.\n</p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' />"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints"		"Back-solve Joints affecting cloth-disabled verts"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints:shorthelp"		"Cloth affects joints with static cloth nodes bound"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints:help"		"<p>\nSometimes it\'s useful for the authored joints to be moved by cloth (see Back-solve Joints checkbox). It\'s not useful when you want to animate them, when you want the animation to affect the cloth. But animation will always affect the <b>static</b> verts/nodes of the cloth, those painted black (in <em>cloth_enable </em>attribute). Those node drive the rest of the cloth simulation, and it would look strange to try to back-solve joints to which those vertices are skinned, because those vertices would be deformed in unexpected ways.\n</p>\n<p>However, sometimes it\'s useful to do so, especially when there are just a few vertices that don\'t deform too much when the joint is rotating. This checkbox allows you to do that. </p>"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch"		"Surface Stretch (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch:shorthelp"		"Range: -inf..+inf. Most useful range: 0..1. Stretchiness, droopiness of cloth surface (but not ropes/rods)"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch:help"		"<p>A measure of stretchiness. 0 is the stiffest. 1 is extremely loose. +inf would effectively disable the solver completely. Small negative values are inherently unstable, but effectively make cloth over-stiff, overshooting the solver on every iteration. It may generate interesting jittery special effects in some cases, but will make cloth unstable in many other cases.</p> \n<p>Technically, this is the rate at which quads and tris are allowed to contract every time step. It is exponential, so 0 becomes the multiplier of exp( 0 ) = 1, allowing for full solve. 1 becomes exp( -1 ) ~= 0.37, so the solver only has the weight of .37, making the solver very droopy and relaxed. Values beyond 1 will quickly make multiplier almost-0, making solver effectively (almost) disabled</p>\n<p><img src=\'toolimages:model_editor/cloth_stretch_demo2.png\' /></p>"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch"		"Rod Stretch (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch:shorthelp"		"Range: -inf..+inf. Most useful range: 0..1. Stretchiness, droopiness of cloth surface (but not ropes/rods)"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch:help"		"<p>A measure of stretchiness. 0 is the stiffest. 1 is extremely loose. +inf would effectively disable the solver completely. Small negative values are inherently unstable, but effectively make cloth over-stiff, overshooting the solver on every iteration. It may generate interesting jittery special effects in some cases, but will make cloth unstable in many other cases.</p>\n<p>Technically, this is the rate at which <b>rods</b> are allowed to contract every time step. It is exponential, so 0 becomes the multiplier of exp( 0 ) = 1, allowing for full solve. 1 becomes exp( -1 ) ~= 0.37, so the solver only has the weight of .37, making the solver very droopy and relaxed. Values beyond 1 will quickly make multiplier almost-0, making solver effectively (almost) disabled</p>\n<p><img src=\'toolimages:model_editor/cloth_stretch_demo2.png\' /></p>"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale"		"Gravity (-inf..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale:shorthelp"		"Range:-inf..+inf; Gravity, 1 means 1 earth gravity -1 means earth gravity directed upwards"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale:help"		"Gravity scale multiplier. 1.0 means normal Earth gravity. -1.0 means gravity, directed upwards. 2 means 2 times the Earth gravity, etc."
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance"		"Triangulate quads bent more than (0..1)"
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance:shorthelp"		"Range: 0..1. Triangulate threshold for non-flat quads"
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance:help"		"Triangulate quads that have curvature over specified threshold. \n0.0 means \"triangulate almost all quads\", because roundoff errors make sure there are almost never completely flat quads (except axis-aligned quads)\nValues close to 1 may cause some weird behavior in some extreme cases.\n1.0 means \"Do not triangulate any quads, even if they are self-intersecting\"\nValues over 1 effectively mean the same."
		"Attribute.CAuthPhysFx.m_flAddCurvature"		"Minimal curvature (0..1)"
		"Attribute.CAuthPhysFx.m_flAddCurvature:shorthelp"		"Range: 0..1. Minimal allowed curvature"
		"Attribute.CAuthPhysFx.m_flAddCurvature:help"		"0 means edges may bend and fold as they please. \n0.5 means edges will try to maintain no less than right-angle bend (or the bend at relaxed position, whichever is smaller)\n1.0 means any edge will try to maintain no more bend than in relaxed position. \n\nIn order for this option to work, <b>m_bAddStiffnessRods</b> must be on. The stiffness rods are controlling the curvature, that\'s how it\'s implemented."
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag"		"Viscous Air Drag (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag:shorthelp"		"Air Drag coefficient multiplied by particle velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag:help"		"Air Drag coefficient multiplied by particle velocity^2, emulates viscous friction effect.\n<ul>\n<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>\n<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>\n<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>\n<li><b>+inf</b> is kind of strange, as it doesn\'t exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>\n"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag"		"Simple Drag (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag:shorthelp"		"Simple linear drag, multiplied by particle velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag:help"		"<P>Simple drag. Comparing to viscous drag: simple drag affects slow-moving particles\n more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>\n<P>Technically, the velocity loss is exponential and proportional to this value.</P>\n<ul>\n<li><b>0.0</b> means there is no drag</li>\n<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn\'t reduce velocity, thus reducing the drag.</li>\n<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>\n<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag"		"Viscous Air Drag across surface area (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag:shorthelp"		"Air Drag coefficient multiplied by quad velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag:help"		"<p><b>Only affects Quads or Tris!</b></p>\n<p>\nAir Drag coefficient multiplied by velocity^2, emulates viscous friction effect. Forces are applied along surface normals, not along particle path directions.</p>\n<p><ul>\n<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>\n<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>\n<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>\n<li><b>+inf</b> is kind of strange, as it doesn\'t exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>\n</p>"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag"		"Simple drag across surface area (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag:shorthelp"		"Simple linear drag across surface area, multiplied by velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag:help"		"<p><b>Only affects Quads or Tris!</b></p>\n<P>Simple drag.  Forces are applied along surface normals, not along particle path directions. Comparing to viscous drag: simple drag affects slow-moving particles\n more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>\n<P>Technically, the velocity loss is exponential and proportional to this value.</P>\n<ul>\n<li><b>0.0</b> means there is no drag</li>\n<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn\'t reduce velocity, thus reducing the drag.</li>\n<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>\n<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag"		"Viscous Air Drag across rope lengths (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag:shorthelp"		"Air Drag coefficient multiplied by rod velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag:help"		"<p><b>Only affects Rods!</b></p>\n<p>\nAir Drag coefficient multiplied by velocity^2, emulates viscous friction effect. Forces are applied across rod lengths, not along particle path directions.</p>\n<p><ul>\n<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>\n<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>\n<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>\n<li><b>+inf</b> is kind of strange, as it doesn\'t exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>\n</p>"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag"		"Simple drag across rod length (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag:shorthelp"		"Simple linear drag across rod lengths, multiplied by velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag:help"		"<p><b>Only affects Rods!</b></p>\n<P>Simple drag.  Forces are applied across rod length, not along particle path directions. Comparing to viscous drag: simple drag affects slow-moving particles\n more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>\n<P>Technically, the velocity loss is exponential and proportional to this value.</P>\n<ul>\n<li><b>0.0</b> means there is no drag</li>\n<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn\'t reduce velocity, thus reducing the drag.</li>\n<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>\n<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>\n</ul>"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate"		"Heavy Leather Surface (0..1)"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate:shorthelp"		"Smoothing velocity field helps achieve \"Heavy leather\" look"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate:help"		"<p>Smooth the velocity field along the surface, to avoid ripples and waves characteristic of light silky cloth, and achieve more heavy, monolithic, shell-like look.</p>"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate"		"Heavy Whip Rope (0..1)"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate:shorthelp"		"Smoothing velocity field helps achieve \"Heavy whip\" look"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate:help"		"<p>Smooth the velocity field along the rope length, to avoid ripples and waves characteristic of soft easily bendable materials, and achieve more heavy, monolithic, rod-like look.</p>"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations"		"Ultra Heavy Surface (0..+inf)"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations:shorthelp"		"Number of iterations the surface velocity field smoothing is applied"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations:help"		"<p><b>Warning: expensive parameter, use with caution!</b></p>\n<p>This is the number of iterations of velocity field smoothing to apply to a surface. Works in conjunction with QuadVelocitySmoothRate</p>"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations"		"Heavy Rope Iterations (0..+inf)"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations:shorthelp"		"Number of iterations the surface velocity field smoothing is applied"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations:help"		"<p><b>Warning: expensive parameter, use with caution!</b></p>\n<p>This is the number of iterations of velocity field smoothing to apply to a surface. Works in conjunction with QuadVelocitySmoothRate</p>"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction"		"S1 Ground Friction (0..1)"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction:help"		"\"Ground Friction\" as defined in S1 cloth. It\'s kind of stickiness to the ground when ground collision is enabled. Do not use in new Source2-authored cloth."
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius"		"Cloth Thickness when colliding with meshes (0..+inf, inches)"
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius:shorthelp"		"Additional radius to add to particles colliding with mesh, because mesh consists of very thin quads"
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius:help"		"When cloth collides with world mesh, only cloth nodes/verts are colliding. Since mesh thickness is essentially zero, particles can easily end up on the wrong side of the mesh. Hence, we need a tuning parameter that stops particles from penetrating the mesh. This is it."
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration"		"S1 World Collision Penetration (0..1)"
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration:shorthelp"		"Source1 compatibility parameter for how much particles penetrate the ground"
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration:help"		"Do not use in Source2 authored cloth"
		"Attribute.CAuthPhysFx.m_flLocalForce"		"S1 Local Force (0..1)"
		"Attribute.CAuthPhysFx.m_flLocalForce:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flLocalForce:help"		"<p>Source 1 compatibility parameter Local Force is used to distinguish whether cloth reacts to entity moving in the world or not (ie. whether it\'s effectively simulated in local entity frame or in the world). </p>\n<p>The meaning of values is kept as in Source 1. The meaning is opposite to LocalRotation, which is frustrating, but compatible with Source 1 .cloth files.</p>\n<p><ul><li><b>0.0</b> Means sim in local frame. Cloth will not react to dragging entity through the world</li>\n<li><b>1.0</b> Means sim in global world frame. Cloth will drag behind entity when moving entity around the world. This is the default.</li>\n</ul>\n</p>"
		"Attribute.CAuthPhysFx.m_flLocalRotation"		"S1 Local Rotation (0..1)"
		"Attribute.CAuthPhysFx.m_flLocalRotation:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flLocalRotation:help"		"<p>Source 1 compatibility parameter Local Rotation is used to distinguish whether cloth reacts to entity moving in the world or not (ie. whether it\'s effectively simulated in local entity frame or in the world). </p>\n<p>The meaning of values is kept as in Source 1. The meaning is opposite to LocalForce, which is frustrating, but compatible with Source 1 .cloth files.</p>\n<p><ul>\n<li><b>0.0</b> Means sim in global world frame. Cloth will drag around rotation axis when rotating entity in the world. </li>\n<li><b>1.0</b> Means sim in local frame. Cloth will not react to rotating entity.</li>\n</ul>\n</p>"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount"		"Back-solve Joint Feedback (0..1)"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount:shorthelp"		"How much the joint back-solve (if any) feeds forward into the simulation"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount:help"		"<p>Joint back-solving is a way for cloth to control the render mesh via its own authored bones, as opposed to controlling render mesh through bones generated from cloth proxy mesh.</p>\n<p>When cloth proxy computes those bones, by default it doesn\'t affect the simulation, it only affects the render mesh</p>\n<p>If you set this to 1.0, the simulation will be affected. The vertices will be rearranged every frame to follow the back-solved joints, effectively creating a volumetric solve effect. It can be useful for plants and other volumetric effect props where it\'s important to maintain initial 3D structure of the object. </p>"
		"Attribute.CAuthPhysFx.m_bFollowTheLead"		"S1 Compatibility"
		"Attribute.CAuthPhysFx.m_bFollowTheLead:shorthelp"		"Source1 compatible non-physical behavior"
		"Attribute.CAuthPhysFx.m_bFollowTheLead:help"		"This ensures the Follow-The-Lead constraint solving strategy for rods. It is non-physical and should never be used for anything, ever. Except to emulate precisely what the Source1 solver does. Also, good for experimenting with bizzare artistic effects."
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation"		"Per-node local force and rotation"
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation:shorthelp"		"Source 1 compatiblity parameter"
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation:help"		"<p>Allow to use per-node LocalForce and LocalRotation parameters</p>\n<p>This currently is only useful to emulate Source1 cloth system with multiple cloth pieces, but in the future if these parameters prove useful, we might paint them as attribute maps on cloth proxies or meshes<p>"
		"Attribute.CAuthPhysFx.m_bUnitlessDamping"		"Unitless Damping"
		"Attribute.CAuthPhysFx.m_bUnitlessDamping:shorthelp"		"Source1 had damping coupled to particle mass. "
		"Attribute.CAuthPhysFx.m_bUnitlessDamping:help"		"Changes the meaning of damping parameter. If this is <b>on</b> (the default), then damping is unitless value with the most useful range of 0..1, and it damps regardless of mass. If it\'s <b>off</b>, then damping is affected by particle mass. Mostly useful for backwards compatibility with source1 cloth assets. Do not use for in new Source2 authored assets unless you are sure you want to couple particle masses and damping."
		"Attribute.CAuthPhysFx.m_bExplicitMasses"		"Explicit masses"
		"Attribute.CAuthPhysFx.m_bExplicitMasses:shorthelp"		"Specify particle masses explicitly, and don\'t allow cloth builder to automatically determine them"
		"Attribute.CAuthPhysFx.m_bExplicitMasses:help"		"<p>Specify particle masses explicitly, and don\'t allow cloth builder to automatically determine them</p>\n<p>When cloth is built, particle masses are normally auto-assigned based on the area of triangles and lengths of rods, so that areas with high vertex density don\'t become overweight</p>\n<p>However sometimes you want cloth to simulate a carefully placed network of nodes where you know exactly how much each node should weigh. In this case, check this checkbox. By default, all masses with be equal to 1.0, unless you paint the cloth_mass map. If you turn this off, cloth_mass will be blended with the vertex surrounding quad areas</p>"
		"Attribute.CAuthPhysFx.m_bUninertialRods"		"S1 Uninertial Rods"
		"Attribute.CAuthPhysFx.m_bUninertialRods:shorthelp"		"Horrible, terrible Source1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_bUninertialRods:help"		"Never, ever turn this on unless trying to emulate Source1 cloth exactly. This kills integrator stability and generally makes all kinds of badness to happen."
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes"		"(Test) Force S1 World Collision on all nodes"
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes:shorthelp"		"Forces all nodes to collide with the ground, in Source1 sense"
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes:help"		"In Source1, \"world collision\" was a per-cloth-piece flag that made a particle collide with the ground plane. This is a test parameter that allows you to force this turned on for all nodes, to make the whole cloth collide with the ground. Useful for quick testing, but may be used for simple ground colliding cloth when performance isn\'t much of an issue."
		"Attribute.CAuthPhysFx.m_nMergePriority"		"Parameter Merge priority"
		"Attribute.CAuthPhysFx.m_nMergePriority:shorthelp"		"Priority of these parameters when merging cloth from multiple sources"
		"Attribute.CAuthPhysFx.m_nMergePriority:help"		"<p>Priority of these parameters when merging cloth from multiple sources.</p>\n<p>When authoring cloth by painting cloth_enable map in Maya, and then changing parameters in Source2 Model Editor, there are two sources of data: that exported from Maya, and that authored in Source2 Model Editor. They are merged together, so that you can author some cloth collision in one, and some in the other, and they will be appended. But some parameters cannot be appended and the cloth compiler has to choose between the two. In these cases, it\'ll choose the source with higher Merge Priority.</p>\n<p> By default, cloth authored in Maya or Modo have priority 1. If, after authoring cloth in Maya or Modo you want to add .collision file to tweak some parameters, it will be assigned priority 2, and will thus override what you authored in Maya (it will not override cloth polygons and such, as they can be merged; but it will override e.g. the default gravity scale multiplier that affects the whole character). However, if you first author some cloth in Model Editor, it\'ll have priority 0. If you then export something from Maya (like cloth proxy), it\'ll have default parameters and priority 1, thus overwriting the parameters you previously authored in Model Editor. To revert back to Model Editor-edited parameters, simply set the priority to 2.</p>\n"
		"Attribute.CAuthPhysFx.m_bNewStyle"		"New Style cloth"
		"Attribute.CAuthPhysFx.m_bNewStyle:shorthelp"		"S1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_bNewStyle:help"		"Used for debugging leave this on, please."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes"		"Collide With Meshes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes:shorthelp"		"Turn on collision with physical mesh shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes:help"		"Turn on collision with physical mesh shapes."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres"		"Collide With Capsules and Spheres"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres:shorthelp"		"Turn on collision with physical capsule and sphere shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres:help"		"Turn on collision with physical capsule and sphere shapes. Turn this on to interact with player\'s capsule, for example."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls"		"Collide With Convex Hulls"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls:shorthelp"		"Turn on collision with physical convex hull shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls:help"		"Turn on collision with physical convex hull shapes"
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods"		"Add Stiffness Rods"
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods:shorthelp"		"Add rods crossing edges that add stiffness to the structure."
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods:help"		"<p>This is just a quality parameter to make cloth more stiff and responsive at the same time. If you want droopy looking, relaxed and stretchy cloth, turn this off, as turning it off will both make cloth more droopy and simulation cheaper.\n</p>\n<p>\nAnother function is to provide bend springs that also act as stretch springs. They will only resist bending if the curvature is not zero, i.e. either you have to paint cloth_bend_stiffness map or set Add Curvature parameter to something more than 0 (1 recommended for less-bendable cloth)\n</p>\n<p>\nThis may create issues sometimes, especially when your (goal) attractor maps are not smooth over 3 consecutive vertices.\n</p>\n<p>\nIf you only want the bend springs without the issues and stiffness that comes with Bend-and-Stretch springs, uncheck this option and check Add Bend-only Springs\n</p>"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges"		"Shell-like No Bend"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges:shorthelp"		"Try to maintain shell-like structure of cloth, avoid bending at the edges"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges:help"		"Use this in conjunction with <em>AddStiffnessRods</em> <b>ON</b> and <em>AddCurvature </em><b>1.0</b> in order to achieve volumetric-like solve effects. Also, you can use this to try to keep cloth in the original shape , so that it\'s shell-like"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders"		"Allow border joint rotation"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders:shorthelp"		"Allow Rotation of Joints at the boder between cloth and rigid surface"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders:help"		"<p>Allow Rotation of Joints at the boder between cloth and rigid surface.</p>\n<p>Cloth render mesh is controlled by joints that move and rotate (and sometimes may stretch and skew, with special setups). Those joints that are just on the border, i.e. joints controlled by animation, often influence both cloth and non-cloth vertices.</p><p> Sometimes it\'s useful to lock those border joints to their animated rotations (positions are normally locked anyway). But sometimes it\'s useful to let them rotate freely while keeping position locked.</p>\n<p>This option allows you to choose between the two modes</p>\n<p><img src=\'toolimages:model_editor/flex_cloth_border_joints.png\' /></p>\n"
		"Element.CVClothProxyMeshList"		"Cloth Proxy Mesh List"
		"Element.CVClothProxyMeshList:help"		"<p>For any prop or character you want to have cloth on, you can either paint cloth_enable attribute on the render mesh, or (if the render mesh topology does not simulate well) model a <b>proxy </b>mesh that will simulate and deform the render mesh as it simulates. </p><p>The deformation resembles that of the maya Wrap deformer, but it happens at runtime, which means there are additional limitations. There may only be up to 4 nodes (the simulating cloth mesh vertices) infuencing a single vertex in the render mesh, which is much more limiting than Maya\'s wrap deformer that may easily use 16 to achieve a smooth look.</p><p> In the cases when you can\'t achieve smooth enough look with it, you can bind both render mesh and proxy mesh to the same skeleton, and enable Back-Solve Joints option in the proxy. Then don\'t paing cloth_enable attribute on the original render mesh (or check the \"Ignore Cloth Attributes\" option on the render mesh to ignore attributes you already painted). You\'ll have the full control over how you skin the render mesh, and the cloth will solve and control those joints, so the skin will deform smoothly no matter what.</p>\n<p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' /></p>"
		"Attribute.CVClothProxyMesh.m_meshName:help"		"The name of the cloth proxy mesh is for documentation purposes only and doesn\'t affect the compilation process"
		"Element.CVClothProxyMesh"		"Cloth Proxy Mesh"
		"Element.CVClothProxyMesh:shorthelp"		"The mesh that will actually simulate, and the simulation will be transferred to render mesh"
		"Element.CVClothProxyMesh:help"		"<p>For any prop or character you want to have cloth on, you can either paint cloth_enable attribute on the render mesh, or (if the render mesh topology does not simulate well) model a <b>proxy </b>mesh that will simulate and deform the render mesh as it simulates. </p><p>The deformation resembles that of the maya Wrap deformer, but it happens at runtime, which means there are additional limitations. There may only be up to 4 nodes (the simulating cloth mesh vertices) infuencing a single vertex in the render mesh, which is much more limiting than Maya\'s wrap deformer that may easily use 16 to achieve a smooth look.</p><p> In the cases when you can\'t achieve smooth enough look with it, you can bind both render mesh and proxy mesh to the same skeleton, and enable Back-Solve Joints option in the proxy. Then don\'t paing cloth_enable attribute on the original render mesh (or check the \"Ignore Cloth Attributes\" option on the render mesh to ignore attributes you already painted). You\'ll have the full control over how you skin the render mesh, and the cloth will solve and control those joints, so the skin will deform smoothly no matter what.</p>\n<p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' /></p>"
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly"		"Back-solved Joints drive meshes"
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly:shorthelp"		"If your cloth proxy has \"Back-solve joints\" checked, this will ensure that no additional bones are created in render meshes."
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly:help"		"<p>This will ensure that no additional bones are created in render meshes, and the existing bones with dynamic proxy verts are back-solved (but also see: ).It\'s equivalent to setting render meshes\' checkbox \"Ignore Cloth Attributes\" and If your cloth proxy checkbox \"Back-solve Joints\".</p>\n<p>In order to create this setup successfully, don\'t forget about the following: <ul><li>You need to skin the proxy as well as render mesh for back-solving to work, because proxy needs to know which vertices connect to which bones. In Modo/Maya, bones drive proxy vertices. The cloth solver puts it upside down and drives bones with vertices. </li><li>You don\'t actually need the cloth_enable map on the driven mesh, because it\'s not participating in anything cloth related. Cloth drives bones, and bones then drive the render mesh, but render mesh doesn\'t need to know about cloth. If you already painted that map and you don\'t want to delete it (it\'s work that may be useful at some point), it\'ll get ignored as if  the \"Ignore Cloth Attributes\" checkbox is checked on all the render meshes. Itll behave as if you never painted the cloth_enable map on it.</li></ul></p>\n\n<p>\n<img src=\'toolimages:model_editor/cloth_backsolve_demo.png\' /></p>"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes"		"Auto-Match proxies to meshes (0..1)"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes:shorthelp"		"Will attempt to match contiguous cloth proxy pieces to render mesh pieces"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes:help"		"<p>When there are multiple cloth pieces that come close to each other or even intersect, this is how you automatically disambiguate which piece of cloth proxy affects which piece of render mesh. Without this option, intersecting cloth pieces will move as if stuck together and will stretch in bad ways.</p>\n\n<ul>\n<li><b>0.0</b> means don\'t try to match, project the whole render mesh onto the cloth proxy mesh</li>\n<li><b>1.0</b> means definitely try to match cloth pieces to render mesh pieces, even if the match is not very good</li>\n</ul>"
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled"		"Remove unused bones"
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled:shorthelp"		"Tries to search and remove bones that do not affect render mesh. Does not affect cloth simulation."
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled:help"		"Tries to search and remove bones that do not affect render mesh. Does not affect cloth simulation."
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms"		"Skin Parented Transforms"
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms:shorthelp"		"Create implicit joints for normal transform and skin meshes to them"
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms:help"		"By default only joints are converted into a game mesh and meshes can only be skinned to joints.  This option will create an implicit joint for every transform in the scene and will also implicitly skin meshes to their closest parent.  This option implies <a href=\'helpsystem:Attribute.CVmesh.m_bSkinParentedObjects\'>Skin Parented Objects</a>"
		"Attribute.CAuthPhysBody.m_bUseInCloth"		"Use in Cloth Collision"
		"Attribute.CAuthPhysBody.m_bUseInCloth:shorthelp"		"Use this shape as collision in cloth"
		"Attribute.CAuthPhysBody.m_bUseInCloth:help"		"When checked, this collision shape will be used in cloth to collide against cloth of the same character. There is a number of restrictions, because cloth doesn\'t use the same collision system as physics for performance reasons.\nCloth supports collision with spheres and capsules. This checkbox will have effect on those. Cloth does not support performant collision with hulls (although there is experimental support, but it\'s too slow to be practical). Cloth also supports collision with planes and tapered capsules, and also \"inside\" collision, where a piece of cloth can be held within the bounds of a sphere or a tapered capsule. \nThere\'s no way to author such collision conveniently in model_editor yet. The plan is to build the tools as we need them.\nNote that different characters will not collide with each other\'s cloth."
		"Attribute.CAuthPhysFx.m_bAddBendOnlyRods"		"Add Bend-only Springs"
		"Attribute.CAuthPhysFx.m_bAddBendOnlyRods:help"		"<p>This option adds traditional bend springs, if curvature is not 0.</p>\n\n<p>That is, you must either paint cloth_bend_stiffness map or set Add Curvature option to non-0 (try 1) for this option to have effect. Also, turn off Bend-and-Stretch springs, because they supercede this option.</p>"

	}
}
